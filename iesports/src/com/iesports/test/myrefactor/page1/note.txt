一
	1.1、傻瓜都能写出让计算机理解的代码，但只有伟大的程序员能写出让任何人类都可以理解的代码
	1.2、类方法中不能直接调用实例方法，但是可以通过将对象实例化(new)之后再调用
	起始类就是java程序的入口类，既是包含main方法的类，也被成为主类
	主类为了方便jvm找到main方法，所以必须的public修饰的，而public 修饰的class 必须与类文件名相同
	注：在java中虽没有主类和次类的分别
	java中不允许有单独的方法和函数存在
	interface 必须为public
	java中数据类型分为基本数据类型和引用数据类型，（基本数据类型也叫作原生类，内置类型）
	那么如int 和boolean 都为基本类型也即是原生类型，但不能进行强制转换
	java中的自增操作是非原子性的
	抽象类和接口中都可以包含静态成员变量，而且接口中的成员变量默认就是public static final类型的
	java 中的普通成员变量就是非静态变量
	接口中 不能包含静态方法，但可以有静态变量
	java只是单继承，但是可以实现多个接口，继承的耦合性太强，java推荐高内聚低耦合的设计思路，不推荐使用继承
	所以多使用implement，少使用extends
	内存空间不足时，可以使用归并排序，
	在排序算法中，如果初始序列有序，则快速排序算法最慢，堆排序算法最快
	排序算法中元素的移动次数和关键字的初始排列次序无关，就是说
	在最好，最快，一般情况下排序的时间复杂度都不变，这类的排序算法有，堆排序，归并排序，选择排序，基数排序
	集合中线程安全的类有：
		vector，stack，hashtable，enumeration，
	除此之外均是非线程安全的类与接口
	
	
	FROM：对FROM子句中的前两个表执行笛卡尔积（Cartesian product)(交叉联接），生成虚拟表VT1
	ON：对VT1应用ON筛选器。只有那些使<join_condition>为真的行才被插入VT2。
	OUTER(JOIN)：如 果指定了OUTER JOIN（相对于CROSS JOIN 或(INNER JOIN),保留表（preserved table：左外部联接把左表标记为保留表，右外部联接把右表标记为保留表，完全外部联接把两个表都标记为保留表）中未找到匹配的行将作为外部行添加到 VT2,生成VT3.如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表为止。
	WHERE：对VT3应用WHERE筛选器。只有使<where_condition>为true的行才被插入VT4.
	GROUP BY：按GROUP BY子句中的列列表对VT4中的行分组，生成VT5.
	CUBE|ROLLUP：把超组(Suppergroups)插入VT5,生成VT6.
	HAVING：对VT6应用HAVING筛选器。只有使<having_condition>为true的组才会被插入VT7.
	SELECT：处理SELECT列表，产生VT8.
	DISTINCT：将重复的行从VT8中移除，产生VT9.
	ORDER BY：将VT9中的行按ORDER BY 子句中的列列表排序，生成游标（VC10).
	TOP：从VC10的开始处选择指定数量或比例的行，生成表VT11,并返回调用者。
	
	包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱
	包装类的equals()方法不处理数据转型 equeals()->会进行自动拆箱装箱，但不会进行类型转换
	
	select into from 和 insert into select都是用来复制表，
	两者的主要区别为： select into from 要求目标表不存在，因为在插入时会自动创建。
	insert into select from 要求目标表存在
	
	在对原数据表需要新增字段时，可以新建一张完整的表，然后将旧表中的数据迁移到新表中
	等新表中数据迁移完成，删除老表，修改信表名称
	
	面向对象五大基本原则：
	单一职责原则：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
	依赖倒转原则：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
	接口隔离原则：使用多个小的专门的接口，而不要使用一个大的总接口
	里氏转换原则：类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。
	开放封闭原则：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。
	
	线程安全问题都是由全局变量及静态变量引起的。即所谓的：脏读
	
	应用程序的主线程以及使用Thread构造的线程都默认为前台线程                       
	使用Thread建立的线程默认情况下是前台线程，在进程中，只要有一个前台线程未退出，进程就不会终止
	main方法所在线程成为主线程，也是前台线程，前台线程未结束，程序不会终止执行
	
	java 中GC即内存回收机制，就是释放掉被占据的内存空间，但是程序员无法明确的强制其运行，
	而是GC在确认该空间在不被引用的时候才会被释放掉，程序员只能引导GC指定某一个对象可以被GC回收，
	但是具体回收工作还需要GC自己来决定
	
	throw与throws的比较
	1、throws出现在方法函数头；而throw出现在函数体。
	2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。
	3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。
	
	JSP内置对象有：
	1.request对象
		客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。
	2.response对象
		response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。
	3.session对象
		session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。
		它是HttpSession类的实例.
	4.out对象
		out对象是JspWriter类的实例,是向客户端输出内容常用的对象
	5.page对象
		page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例
	6.application对象
		application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，
		此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；
		在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。
		它是ServletContext类的实例。
	7.exception对象
		exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，
		就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象
	8.pageContext对象
		pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，
		也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。
	9.config对象
		config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数
		（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）
	
	
	